package PHEDEX::Transfer::FDT;
use base 'PHEDEX::Transfer::Command', 'PHEDEX::Core::Logging', 'PHEDEX::Transfer::Core';

# author: Zdenek Maxa, zdenek.maxa@cern.ch
#
# PhEDEx data transfer backend for using FDT (Fast Data Transfer)
# FDT http://monalisa.cern.ch/FDT/
# module is part of the project aimed at integrating FDT with PhEDEx:
# https://twiki.cern.ch/twiki/bin/view/Main/PhEDExFDTIntegration
# this twiki summarizes relation among all main blocks of FDT-based
# transfers (PhEDEx, FDT.pm, fdtcp/fdtd, FDT Java (fdt.jar))
#
# This module is interface between PhEDEx transfer system (and thus
# part of the PhEDEx codebase) and command-line transfer client
# application fdtcp - fdtcp project.
#
# fdtcp command-line application can be used independently on PhEDEx
# and has interface analogous to SRM - srmcp.
#
# This module is largely based on SRM.pm transfer
# backend (PHEDEX::Transfer::SRM).
#
# The project twiki summarizes installation and PhEDEx configuration
# instructions. Following is an agent configuration example for FDT
# transfers (3 parallel transfers of 10 files per job):
#
#	### AGENT LABEL=download-debug-nebraska PROGRAM=Toolkit/Transfer/FileDownload
#	-db              ${PHEDEX_DBPARAM}
#	-nodes           ${PHEDEX_NODE}
#	-delete          ${PHEDEX_CONF}/FileDownloadDelete
#	-validate        ${PHEDEX_CONF}/FileDownloadVerify,-d
#	-accept          'T2_US_Nebraska'
#	-verbose
#	-backend         FDT
#	-protocols       fdt
#	-batch-files     10
#	-max-active-files 30
#	-jobs            3
# 	-command         /usr/bin/fdtcp,--debug=DEBUG,--timeout=10
#
# The are no new extra options introduced for the FDT backend.
#
# The full list of options for fdtcp command can be obtained by
#	fdtcp --help
# The command takes grid proxy certificate location specified
#	either as environment variable or command-line option. 
#
#
# Some implementation notes:
# copyjobfile processing implemented in fdtcp
# report file is generated by fdtcp, it doesn't consider partial
# 	transfers - everything either succeeds or fails. If partial 
# 	transfers are to be supported (i.e. some files from batch
# 	succeed, some not), then it will have to be implemented
#	in FDT Java (fdt.jar).
#
# logging added: $self->Logmsg('msg');
#
# SCM information: Revision = "$Revision$ Tags = "$Tags$"


use PHEDEX::Core::Command;
use PHEDEX::Core::Timing;
use POE;
use Getopt::Long;

use strict;
use warnings;



sub new
{
    my $proto  = shift;
    my $class  = ref($proto) || $proto;
    my $master = shift;
    
    # Get derived class arguments and defaults
    my $options = shift || {};
    my $params  = shift || {};

    # Set my defaults where not defined by the derived class.
    $params->{PROTOCOLS}   ||= [ 'fdt' ];  	# Accepted protocols
    $params->{COMMAND}     ||= [ 'fdtcp' ]; # Transfer command
	
    # Initialise myself
    my $self = $class->SUPER::new($master, $options, $params, @_);
    bless $self, $class;
    return $self;
}



sub setup_callbacks
{
    my ($self, $kernel, $session) = @_;
    $kernel->state('fdt_job_done', $self);
}



# Transfer a batch of files.
sub start_transfer_job
{
    my ( $self, $kernel, $session, $jobid ) = @_[ OBJECT, KERNEL, SESSION, ARG0 ];

    my $job = $self->{JOBS}->{$jobid};
    my @tasks = values %{$job->{TASKS}}; # specification of tasks src, dst

    # reportfile is a list of transfers like in copyjobfile and status integers
    #	status values are not functionally relevant for PhEDEx
    #   agent does its own check to see if file was successfully transfered,
    #   however this information provided in report appears on the web and is
    #   relevant for operation only to evaluate and understand problems,
    #   functionally it is not used in PhEDEx
    #   fdtcp may be too verbose in providing full log from the client FDT Java
    #   party on a failed transfer per file.
    # log output of the command
    my $spec     = "$job->{DIR}/copyjob";
    my $report   = "$job->{DIR}/report";
    my $log      = "$job->{DIR}/log";
    my $fdtcpLog = "$job->{DIR}/fdtcp.log";

    # Now generate copyjob
    $self->writeSpec($spec, @tasks);

    # Prepare the command
    my @command = (@{$self->{COMMAND}}, $self->makeArgs($spec, $report, $log, $fdtcpLog));

    # Queue the command
    $self->{JOBMANAGER}->addJob( $session->postback('fdt_job_done'),
				 { TIMEOUT => $self->{TIMEOUT},
				   LOGFILE => $log,
				   REPORT  => $report,
				   START => &mytimeofday(),
				   JOBID => $jobid },
                   @command );

    $job->{STARTED} = &mytimeofday();
    
    $self->Logmsg("start_transfer_job(): log: ", $log);
    $self->Logmsg("start_transfer_job(): report: ", $report);
    $self->Logmsg("start_transfer_job(): copyjobfile: ", $spec);
    $self->Logmsg("start_transfer_job(): command: ", @command);
}



sub fdt_job_done
{
    my ($self, $kernel, $context, $args) = @_[ OBJECT, KERNEL, ARG0, ARG1 ];
    my ($jobinfo) = @$args;
    my $jobid = $jobinfo->{JOBID};
    my $report = $jobinfo->{REPORT};
    my $job = $self->{JOBS}->{$jobid};
    my $log = &input($jobinfo->{LOGFILE});
    my $now = &mytimeofday();

    # If we have a srmcp-style transfer report, read that in now.
    my %taskstatus = ();
    if (-s $report)
    {
	# Read in tasks to get the PFNs
	my %pfns2task;
	foreach my $task (values %{$job->{TASKS}})
	{
	    next if ! $task;
	    
	    my ($from, $to) = @$task{"FROM_PFN", "TO_PFN"};
	    $pfns2task{$from}{$to} = $task->{TASKID};
	}

	# Read in the report and correlate with a task
	foreach (split (/\n/, &input($report) || ''))
	{
	    my ($from, $to, $status, @rest) = split(/\s+/);
	    # skip garbage
	    next if !($from && $to && defined $status &&
		      exists $pfns2task{$from}{$to});
	    $taskstatus{$pfns2task{$from}{$to}} = [ $status, "@rest" ];
	}
    }

    # Report completion for each task
    foreach my $task (values %{$job->{TASKS}}) {
	next if ! $task;
	my $taskid = $task->{TASKID};

	my $xferinfo = { START => $jobinfo->{START}, 
			 END => $now,
			 STATUS => $jobinfo->{STATUS},
			 DETAIL => "",
			 LOG => $log };

	if ($taskstatus{$taskid}) {
	    # We have an srmcp-style report entry, use that
	    ($xferinfo->{STATUS}, $xferinfo->{DETAIL}) = @{$taskstatus{$taskid}};
	} else {
	    # Use the default Command results
	    $self->report_detail($jobinfo, $xferinfo);
	}
	$kernel->yield('transfer_done', $taskid, $xferinfo);
    }
    
    $self->Logmsg("fdt_job_done(): log: ", $log);
}



# Prepare files and command line arguments for the fdtcp command.
sub writeSpec
{
    my ($self, $spec, @tasks) = @_;

	# result of write writing operation
	my $rv = 0;
	# spec - name for the copyjobfile (batch file containing FROM_PFN TO_PFN pairs)
	my $specContent = "";
	
	$specContent = join ("\n", map { "$_->{FROM_PFN} $_->{TO_PFN}" } @tasks);
	$rv = &output ($spec, $specContent);
	
	$self->Logmsg("writeSpec(): spec: ", $spec);
	$self->Logmsg("writeSpec(): tasks: ", @tasks);
	$self->Logmsg("writeSpec(): rv: ", $rv);
    $self->Logmsg("writeSpec(): specContent: ", $specContent);

    return $rv;
}



# Create command line arguments for the transfer command.
sub makeArgs
{
    my ($self, $spec, $report, $log, $fdtcpLog) = @_;
    
    # for fdtcp internal logging: "--logFile=<file>" not the same as $log - will be overwritten 
    return ("--copyjobfile=$spec", "--report=$report", "--logFile=$fdtcpLog");    
}

1;
